#pragma once
#include "afx.h"
class CDib;
class XingTaiDib :
	public CObject//这一章的形态学腐蚀都是针对二值图像来操作的，需要调用第7章的二值函数
{
private:
	CDib *dib;
	/*用于收集信息的“探针”，称为结构元素。
	*/
public:
	XingTaiDib(void);//这里通过程序建立的函数就自动加上了这个，但是以前自己写的一些没有加就暂且这样了
	~XingTaiDib(void);
	void GetDib(CDib *dib);
	/*
	腐蚀作用是消除边界点，使边界向内部收缩，把小于结构元素的物体去掉；如果两个物体之间有细小的连通，通过腐蚀可以把他们分开。
	将结构元素中心进行平移，如果结构元素覆盖的面积内元素全部与结构元素相同就保留当前点，不满足就删除。
	*/
	void ShuiPingFuShi();//原图中落在结构元素内的点至少有一个白点，中心就是白色；水平腐蚀，使用的是[0 0 0]结构元素，判断前一点或者后一点是否是背景点，是的话就赋值为背景；由于结构元素是3个一行，所以第一列和最后一列不处理;效果就是周围小了一圈
	void ChuiZhiFuShi();//垂直腐蚀
	void QuanFangXiangFuShi();//全方向腐蚀
	/*
	膨胀是使边界向外扩充，如果两个物体比较近，膨胀有可能把两个物体连在一起，对跳虫空洞很有用。
	如果目标与结构元素至少有一个点相同，则保留或进行扩充。
	*/
	void ShuiPingPengZhang();//代码跟水平腐蚀差不多，只是赋值不同；图像扩充，保留内部细节；原图中至少有一点在结构元素内是黑色，中心点就是黑色
	void ChuiZhiPengZhang();//垂直膨胀
	void QuanFangXiangPengZhang();//全方向膨胀
	//腐蚀和膨胀是不可逆的
	void KaiYunSuan();//开运算：先腐蚀后膨胀，能够去除孤立的小点、毛刺和小桥，平滑较大物体的边界，同时并不明显改变其面积
	void BiYuanSuan();//闭运算：先膨胀后腐蚀，能够填充物体内细小空洞、连接临近物体、平滑其边界，总的位置和面积不太变
	/*
	击中击不中变换（HMT)：
	说法1：要在X中找出B的位置，先用一个比B大的W模板去腐蚀X得到X1，然后用B-W得到M模板(W-B)，用M腐蚀X的补集得到X2，X1与X2取交集，结果就是B的位置，不一定是B的中心，要看W-B的对齐情况
	说法2：
	1.对 目标图像 进行 目标结构元素 的腐蚀操作。
    2.对 目标图像的对偶 进行 背景结构元素 的腐蚀操作。
    3.最后取两次结果的交集。
	http://blog.csdn.net/stscsdn/article/details/52506586
	就是寻找结构元素在原图中的位置，最后出来的位置不一定是中心位置，看对齐情况。
	*/
	void XiHua();//细化，没看懂，ma慢慢摸索，先敲出来吧;一层层剥出骨架；5x5的，所以上下左右2行不处理;目的是将图像的骨架提取出来，同时保持细节部分的连通性，特别是在文字识别、工业零件识别、地质识别或图像理解中，有助于突出形状特点和减少冗余信息量;实际上是腐蚀操作的变体
	//细化的方法很多，这里只是其中一个；细化对于拐角的骨架不予提取
	/*细化的代码第3和第4个条件和书上不一样，http://blog.sina.com.cn/s/blog_a4034b280101586l.html 这里解释蛮好
	细化烧火柴我理解，但是代码的原理我是不理解的。
	细化是原图减去击中击不中变换的结果，所以逐渐变细。
	粗化是原图加上击中击不中的结果，所以逐渐变粗。
	*/
	void CuHua();//粗化，实际上就是通过对图像的补集进行细化而得到的
	void ZhongZhou();//中轴提取对拐角处的骨架提取延伸到了边界，而细化对于拐角的骨架不予提取
	/*
	这里的细化、粗话和中轴变换和书上不一样。
	*/
};

