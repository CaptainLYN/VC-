#pragma once
class FenGeCeLiangDib:public CObject
{
private:
	CDib *dib;
	/*
	当灰度直方图峰型分布明显时，常以谷底作为门限候选值。
	*/
public:
	void GetDib(CDib *d);
	void YuZhiFenGe(int yuzhi);//阈值分割。大于等于阈值255，否则0
	void BanYuZhi(int yuzhi);//半阈值分割，大于保持，小于为255或0；或者大于255为0或255，小于保持。
	/*迭代阈值运用了逼近的思想，对于双峰明显，谷底较深的图像有很好的效果，但是分布比较均匀或前景和背景数量相差较大的图像，效果不好。
	另外，从网上看到最大类间方差阈值法，取的阈值能让两部分相差最大的阈值就是所求阈值。背景或前景的一部分在另一部分里面时都会造成方差差值变小
	*/
	void DieDaiYuZhi();//获取直方图数据，取平均值，分成两半，分别计算平均值，然后使得平均值=（s1+s2)/2，不断迭代，直到均值数值不变为止
	void LunKuoTiQu();//简单的轮廓提取，如果中心点是黑点，周围8个点也是黑点，就清除（变白）;黑色面积大的区域处理时间长，因为内部使用了迭代阈值二值化
	bool BiHeGenZong();//原来的时候找不到一个闭合圈就会一直循环下去，这里设置一个数，找不到就停止并提示。智能找到一个闭合，闭合曲线适用！先在图片左下角选一个黑点，然后左上是黑点，下一次逆时针旋转90度，如果不是顺时针旋转45度，直到回到起始点
	void QuYuZengZhang(CPoint pt);//前面理论上讲的是在种子点的上下左右增长，而实际上的代码跟门限阈值差不多，不过就是种子点要通过鼠标获取（未实现）
	/*标记，满足阈值条件的连续点就是“条”。扫描有3个模板：
	1、该条不与任何域连接就是新域，加新标记。
	2、与已有域连接，合并。
	3、和两个域连接，将三个合并。
	因此，做模板查找时只需要跟各域的最后一条比较，计算量很小。
	对于4连通区域，标记（A代表物体，0代表背景）当前物体点P：
	1、当左前一点和上面一点皆为背景点时，p加新标记；
	2、左前和上有一个是0时，另一个是标记，则p与加标记点加同样标记；
	3、当左前和上加不一样标记时，p与左点标记相同。
	需要第二次扫描，来把同一物体的不同标记统一起来。
	8连通区域，p与左前、左上、上、右上四个点相关：
	1、4个点都是背景，p加新标记。
	2、有一邻点有标记，p加相同标记。
	3、多个标记时与左前方相同，然后第二遍扫描归一化。

	下面这个算法（8连通），没查到一个新连通域数值标记加一，但是后来归一化容易把中间一些值全消掉，但是数值是只增长的，最后数值是不连续的。
	*/
	int ErZhiBiaoJi(LPBYTE temp,int flag[]);//二值图像区域标记，8连通区域标记为同一个数字
	void ErZhiZhouChang();//将原图化为二值图像，利用标记法规划出区域，利用边界跟踪法跟踪出周长；核心还是边界跟踪法
	void XiaoChuXiaoQuYu(int m_value);//消除小于m_value的区域，利用ErZhiBiaoJi函数
	void ShuiPingTouYing();//水平投影
	void ChuiZhiTouYing();//垂直投影
	/*
	纹理基元，由像素组成的一定大小和形状的集合；纹理是由纹理基元排列组合而成的。
	在不知道纹理基元或未检测出基元的情况下进行纹理分析，只能从像素开始建立纹理特征的模型。纹理的结构分析师砸已知基元的情况下进行的分析。
	方法：
	1、统计方法，用于分析像木纹、沙地那样的纹理细而且不规则的物体。
	    （a）空间域，基于统计图像像素灰度级的分布状况，如利用直方图；研究分布图，与已知纹理进行比对。
		     1、判断直方图相似性：直方图的均值、方差、Kolmogorov-Smirnov检测（看一下电子书还是可以理解的）。
		     2、边缘方向直方图分析法
			 3、图像的自相关函数分析法
			 4、灰度共生矩阵特征分析法
		（b）频域，将图像变换到傅里叶变换的频域中然后抽取相应的象征量。
	2、结构方法，用于印刷或砖花样等一类纹理基元及其排列较规则的图像。

	
	*/
};